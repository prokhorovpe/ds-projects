"""
 Файл с глобальными константами и настройками. Централизованное управление параметрами.
 ВСЕ настройки проекта должны быть здесь. Это упрощает настройку и поддержку.
"""
import os
import pandas as pd

# --- Пути к файлам и директориям ---
# Определяем корневые директории проекта. Они создаются автоматически, если не существуют.
DATA_DIR = "data"
MODEL_DIR = "models"
RESULTS_DIR = "results"
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(MODEL_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)

# Пути к конкретным файлам данных.
RAW_DATA_PATH = os.path.join(DATA_DIR, "yandmast_obr2.csv")  # Исходный CSV-файл
PROCESSED_DATA_PATH = os.path.join(DATA_DIR, "service_time_series.pkl")  # Обработанные временные ряды

# --- Параметры данных ---
# Столбцы, которые будут загружаться из исходного файла. Остальные игнорируются для экономии памяти.
REQUIRED_COLUMNS = ['study_date', 'inventory_number', 'type_of_service']
# Период, за который строятся временные ряды. Все данные вне этого периода отбрасываются.
START_DATE = '2024-01-01'
END_DATE = '2025-06-30'

# --- Параметры моделирования ---
# Автоматически рассчитываем дату начала тестового периода (первый день последнего месяца в данных).
END_DATE_TS = pd.to_datetime(END_DATE)
TEST_START_DATE = END_DATE_TS.replace(day=1).strftime("%Y-%m-%d")
# Дата начала прогноза (день, следующий за END_DATE) и количество дней для прогноза.
FORECAST_START_DATE = (END_DATE_TS + pd.Timedelta(days=1)).strftime("%Y-%m-%d")
FORECAST_PERIOD_DAYS = 123  # <-- Изменено на 123 дня для финального прогноза
# Фиксируем RANDOM_STATE для воспроизводимости результатов.
RANDOM_STATE = 42

# --- Календарные параметры ---
# Определяем "окна выплат", когда наблюдается повышенная активность.
PAY_WINDOW_START = 1
PAY_WINDOW_END = 7
PAY_WINDOW_MID_START = 15
PAY_WINDOW_MID_END = 20

# --- Жестко заданный список праздников ---
# Список государственных праздников РФ. Используется для создания календарных признаков.
# ВАЖНО: Этот список нужно обновлять вручную каждый год.
RU_HOLIDAYS = {
    "2024-01-01", "2024-01-02", "2024-01-03", "2024-01-04", "2024-01-05", "2024-01-06", "2024-01-07", "2024-01-08",
    "2024-02-23", "2024-03-08", "2024-05-01", "2024-05-09", "2024-06-12", "2024-11-04", "2024-12-31",
    "2025-01-01", "2025-01-02", "2025-01-03", "2025-01-04", "2025-01-05", "2025-01-06", "2025-01-07", "2025-01-08",
    "2025-01-07", "2025-02-23", "2025-02-24", "2025-03-08", "2025-03-13", 
    "2025-05-01", "2025-05-02", "2025-05-03", "2025-05-04", "2025-05-05", "2025-05-06", "2025-05-07", "2025-05-08", 
    "2025-05-09", "2025-05-10", "2025-05-11", "2025-06-12", "2025-06-13", "2025-06-14", "2025-06-15"
}
# Преобразуем строки в объекты datetime для внутреннего использования.
RU_HOLIDAYS = set(pd.to_datetime(list(RU_HOLIDAYS))) if 'pd' in globals() else None

# --- Классификация модальностей ---
# Модальности с высокой частотой исследований используют гибридную модель Prophet + XGBoost.
HIGH_FREQUENCY_MODALITIES = ['РГ', 'ММГ']
# Модальности с низкой частотой используют модель детекции всплесков (классификация + регрессия).
SPECIALIZED_MODALITIES = ['Денс', 'ФЛГ', 'КТ', 'МРТ']

# --- Словарь расшифровки модальностей ---
# Используется для удобочитаемого вывода в логах и отчетах.
SERVICES_DICT = {
    'РГ': 'Рентгенография',
    'ФЛГ': 'Флюорография', 
    'ММГ': 'Маммография',
    'КТ': 'Компьютерная томография',
    'МРТ': 'Магнитно-резонансная томография',
    'Денс': 'Денситометрия'
}